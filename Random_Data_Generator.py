### Imports
# Standard libraries
import random
import os
import copy

# Standard third-party libraries
import numpy as np
import pandas as pd

# Miscellaneous
!pip install --quiet names
import names

!pip install --quiet barnum
import barnum
from barnum import gen_data

### Data Sets
# University List
university_df = pd.read_csv("us_universities.csv")
university_series = university_df["name"]
university_list = [row for idx, row in university_series.items()] 

# Bachelor's
bachelors_majors_series = pd.read_csv("majors-list.csv")["Major"]
bachelors_majors_list = [row.lower().title() for idx, row in bachelors_majors_series.items()]

# Master's
masters_majors_series = pd.read_csv("grad-students.csv")["Major"]
masters_majors_list = [row.lower().title() for idx, row in masters_majors_series.items()]


### Modules
## Individual Column Data Modules
# Randon Name Module
class RandomNameGenerator():
    def __init__(self, num_names_unique : int, num_names_complete : int) -> None:
        '''
        Inputs:
            num_names_unique - The number of unique names you'd like to generate. Recommendation: ~75% of your total final pd.DataFrame should contain unique individuals.
            num_names_complete - The complete number of names you'd like to generate. This should correspond to the total number of entries contained in the pd.DataFrame you'd like to reproduce.
        '''
        self.num_names_unique = num_names_unique
        self.num_names_complete = num_names_complete
    
    def __call__(self) -> pd.Series:        
        names_list = RandomNameGenerator._generate_random_names(self.num_names_unique)
        random_names_series = RandomNameGenerator._duplicate_random_names(names_list, self.num_names_complete)

        return random_names_series

    @staticmethod
    def _generate_random_names(num_names : int) -> list:
        '''
        Inputs:
            num_names - Number of unique names to randomly generate. I'd recommend generating enough random names such that ~75% of names
            in your final pd.Series are unique.
        '''
        names_list = []
        for _ in range(num_names):
            names_list.append(names.get_full_name())

        # Double-checking measure to ensure that all the names generated by this method are unique.
        assert len(list(set(names_list))) == len(names_list), _generate_random_names(num_names)
        
        return names_list

    @staticmethod
    def _duplicate_random_names(names_list : list, num_names: int) -> pd.Series:
        '''
        Inputs:
            num_names - Number of names in your final pd.Series. The number of names provided should be the exact amount of entries you want
            in your final pd.Series.
        '''
        difference = num_names - len(names_list)
        temp_list = names_list
        for _ in range(difference):
            name = random.choice(names_list)

            # To mimick the structure of the Veracross database output, any duplicates must appear one after the other.
            temp_list.insert(int(temp_list.index(name)) + 1, name)

        random_names_series = pd.Series(temp_list, index = range(len(temp_list)))

        del temp_list

        return random_names_series

# Random Employer Generator
class RandomEmployerNameGenerator():
    def __init__(self, person_names_series: pd.Series) -> None:
        '''
        Inputs:
            person_names_series - pd.Series generated via a call to RandomNameGenerator.
        '''
        self.persons_series = person_names_series
        self.persons_list_complete = [row for idx, row in person_names_series.items()]
        self.persons_list_unique = list(set(self.persons_list_complete))

    def __call__(self) -> pd.Series:
        '''Generate a pd.Series of randomly-generated employer names '''
        employer_unique_dict = RandomEmployerNameGenerator._generate_employer_unique(self.persons_list_unique)

        employer_series = pd.Series([employer_unique_dict[str(name)] for _, name in self.persons_series.items()], index=range(len(self.persons_list_complete)))

        return employer_series

    @staticmethod
    def _generate_employer_unique(persons_list_unique : list) -> dict:
        employer_unique_dict = {person: str(gen_data.create_company_name()) for person in persons_list_unique}

        return employer_unique_dict

# Random Job Title Generator
# Class
class RandomJobTitleGenerator(RandomEmployerNameGenerator):
    def __call__(self) -> pd.Series:
        '''This dunder method generates a pd.Series containing our randomly-generated job titles, based upon our randomly-generated person names pd.Series.'''
        jobtitle_unique_dict = RandomJobTitleGenerator._generate_jobtitle_unique(self.persons_list_unique)

        jobtitle_series = pd.Series([jobtitle_unique_dict[str(name)] for _, name in self.persons_series.items()], index=range(len(self.persons_list_complete)))

        return jobtitle_series
    
    @staticmethod
    def _generate_jobtitle_unique(persons_list_unique : list) -> dict:
        '''
        This method generates a dictionary containing all unique individuals in our randomly-generated DataFrame as keys, and their 
        randomly-generated job titles as values. 
        '''
        jobtitle_unique_dict = {person: str(gen_data.create_job_title()) for person in persons_list_unique}

        return jobtitle_unique_dict

# Random University Generator
class RandomUniversityGenerator():
    def __init__(self, person_names_series : pd.Series) -> None:
        '''
        Inputs:
            person_names_series - pd.Series generated via a call to RandomNameGenerator.
        '''
        self.persons_series = person_names_series
        self.persons_list_complete = [row for idx, row in person_names_series.items()]
        self.persons_list_unique = list(set(self.persons_list_complete))

    def __call__(self) -> pd.Series:
        '''This dunder method generates a pd.Series containing our randomly-generated universities, based upon our randomly-generated person names pd.Series.'''
        university_unique_dict = RandomUniversityGenerator._generate_university_unique(self.persons_list_unique)

        university_series = pd.Series([university_unique_dict[str(name)] for _, name in self.persons_series.items()], index=range(len(self.persons_list_complete)))

        return university_series

    @staticmethod
    def _generate_university_unique(persons_list_unique : list) -> dict:
        return {person: random.choice(university_list) for person in persons_list_unique}

# Random Field of Study Generator
class RandomFieldOfStudyGenerator(RandomUniversityGenerator):
    def __init__(self, person_names_series : pd.Series, majors_list : list, masters : bool = False) -> None:
        '''
        Inputs:
            person_names_series - pd.Series generated via a call to RandomNameGenerator.
            
            majors_list - List of majors to pull from when randomly assigning majors to randomly-generated individuals.
            
            masters - If True, this variable indicates that majors_list is a list of Master's degrees. Otherwise, majors_list is a list of 
            Bachelor's degrees. By default, this variable is False.
        '''
        super().__init__(person_names_series)
        self.majors_list = majors_list
        self.major_type = "Masters" if masters else "Bachelors"
    
    def __call__(self) -> pd.Series:
        '''This dunder method generates a pd.Series containing our randomly-generated majors, based upon our randomly-generated person names pd.Series.'''
        majors_unique_dict = RandomFieldOfStudyGenerator._generate_major_unique(self.persons_list_unique, self.majors_list)

        majors_series = pd.Series([majors_unique_dict[str(name)] for _, name in self.persons_series.items()], index=range(len(self.persons_list_complete)))

        return majors_series

    @staticmethod
    def _generate_major_unique(persons_list_unique : list, majors_list : list) -> dict:
        return {person: random.choice(majors_list) for person in persons_list_unique}

# Random Degree Generator
class RandomDegreeGenerator(RandomFieldOfStudyGenerator):
    def __init__(self, person_names_series : pd.Series, masters_degrees_list : list, bachelors_degrees_list : list, masters_majors_list : list, bachelors_majors_list : list, masters : bool = False) -> None:
        '''
        Inputs:
            person_names_series - pd.Series generated via a call to RandomNameGenerator.

            masters_degrees_list - List of Master's degrees to use to randomly generate Degree entries for individuals.

            bachelors_degree_list - List of Bachelor's degrees to use to randomly generate Degree entries for individuals.
            
            masters_majors_list - List of Master's majors used to randomly-generate Field of Study entries for individuals.

            bachelors_majors_list - List of Bachelor's majors used to randomly-generate Field of Study entries for individuals.
            
            masters - If True, this variable indicates that majors_list is a list of Master's degrees. Otherwise, majors_list is a list of 
            Bachelor's degrees. By default, this variable is False.
        '''
        if masters:
            super().__init__(person_names_series = person_names_series, majors_list = masters_majors_list, masters = masters)
        else:
            super().__init__(person_names_series = person_names_series, majors_list = bachelors_majors_list, masters = masters)

        self.degrees_list = masters_degrees_list if masters else bachelors_degrees_list

    def __call__(self) -> pd.Series:
        '''This dunder method generates a pd.Series containing our randomly-generated degrees, based upon our randomly-generated person names pd.Series.'''
        degrees_unique_dict = RandomDegreeGenerator._generate_degree_unique(self.persons_list_unique, self.degrees_list)

        degrees_series = pd.Series([degrees_unique_dict[str(name)] for _, name in self.persons_series.items()], index=range(len(self.persons_list_complete)))

        return degrees_series        
    
    @staticmethod
    def _generate_degree_unique(persons_list_unique : list, degrees_list : list) -> dict:
        return {person: random.choice(degrees_list) for person in persons_list_unique}

# Random Additional Notes Generator
class RandomAdditionalNotesGenerator():
    def __init__(self, majors_name_series : pd.Series, degrees_series : pd.Series, masters : bool = False) -> None:
        '''
        Inputs:
            majors_name_series - pd.Series containing the randomly-generated major info (for the Field of Study column, among other uses).
            
            degrees_series - pd.Series containing the randomly-generated degree info (for the Degree column, among other uses).
            
            masters - If yes, this Boolean value tells us that the majors_name_series & degrees_series is a column of randomly-generated 
            Master's majors & degrees, respectively. This info is important for formatting the output when we call this class. By default,
            this value is False.
        '''
        # Major info
        self.majors_name_series = majors_name_series
        self.majors_list_complete = [row for idx, row in self.majors_name_series.items()]

        # Degree info
        self.degrees_series = degrees_series
        self.degrees_list_complete = [row for idx, row in self.degrees_series.items()]

        # Boolean value
        self.masters = masters

    def __call__(self) -> pd.Series:
        if self.masters:
            return pd.Series([f"{degree}, {major}; https://www.link.com" for degree, major in zip(self.degrees_list_complete, self.majors_list_complete)], index = range(len(self.majors_list_complete)))
        else:
            return pd.Series([f'Official Major Title: "{major}"; https://www.link.com' for major in self.majors_list_complete], index = range(len(self.majors_list_complete)))

# Random Email Address Generator
class RandomEmailAddressGenerator():
    def __init__(self, person_names_series : pd.Series, random : bool = False) -> None:
        '''
        Inputs:
            person_names_series - pd.Series containing the list of randomly-generated person names.
            
            random - If True, a sequence of three digits (ranging from 0 to 9) will be added before the '@' symbol in the generated email 
            address. By default, this argument is set to False.
        '''
        self.person_names_series = person_names_series
        self.person_list_complete = [row for idx, row in self.person_names_series.items()]

        self.random = random

    def __call__(self) -> pd.Series:
        first_name_list = [person.split()[0] for person in self.person_list_complete]
        last_name_list = [person.split()[1] for person in self.person_list_complete]
        
        if self.random:
            return pd.Series([f"{first_name}.{last_name}{"".join([str(random.randint(0,9)) for _ in range(3)])}@gmail.com" for first_name, last_name in zip(first_name_list, last_name_list)], index = range(len(self.person_list_complete)))
        else:
            return pd.Series([f"{first_name}.{last_name}@gmail.com" for first_name, last_name in zip(first_name_list, last_name_list)], index = range(len(self.person_list_complete)))

# Random Phone Number Generator
class RandomPhoneNumberGenerator():
    def __init__(self, person_names_series : pd.Series) -> None:
        '''
        Inputs:
            person_names_series - pd.Series containing the list of randomly-generated person names.
        '''
        self.person_names_series = person_names_series
        self.person_list_complete = [row for idx, row in self.person_names_series.items()]
        self.person_list_unique = list(set(self.person_list_complete))

    def __call__(self) -> pd.Series:
        phone_numbers_unique_dict = RandomPhoneNumberGenerator._generate_random_phone_number(self.person_list_unique)

        phone_numbers_series = pd.Series([phone_numbers_unique_dict[str(name)] for _, name in self.person_names_series.items()], index=range(len(self.person_list_complete)))

        return phone_numbers_series

    @staticmethod
    def _generate_random_phone_number(person_list_unique : list) -> dict:
        return {person: str(gen_data.create_phone()) for person in person_list_unique}

# Random Person ID Generator
class RandomPersonIDGenerator():
    def __init__(self, person_names_series : pd.Series) -> None:
        '''
        Inputs:
            person_names_series - pd.Series containing the list of randomly-generated person names.
        '''
        self.person_names_series = person_names_series
        self.person_list_complete = [row for idx, row in self.person_names_series.items()]
        self.person_list_unique = list(set(self.person_list_complete))

    def __call__(self) -> pd.Series:
        person_ids_unique_dict = RandomPersonIDGenerator._generate_unique_IDs(self.person_list_unique)
        persons_ids_series = pd.Series([person_ids_unique_dict[str(name)] for _, name in self.person_names_series.items()], index=range(len(self.person_list_complete)))
        return persons_ids_series

    @staticmethod
    def _generate_unique_IDs(person_list_unique : list) -> dict:
        return {person : f"{"".join([str(random.randint(0,9)) for _ in range(4)])}" for person in person_list_unique}

# Random Roles Generator
class RandomRolesGenerator():
    def __init__(self, person_names_series : pd.Series) -> None:
        '''
        Inputs:
            person_names_series - pd.Series containing the list of randomly-generated person names.
        '''
        self.person_names_series = person_names_series
        self.person_list_complete = [row for idx, row in self.person_names_series.items()]
        self.person_list_unique = list(set(self.person_list_complete))

    def __call__(self) -> pd.Series:
        random_roles_unique_dict = RandomRolesGenerator._generate_random_roles(self.person_list_unique)
        random_roles_series = pd.Series([random_roles_unique_dict[str(name)] for _, name in self.person_names_series.items()], index=range(len(self.person_list_complete)))
        return random_roles_series

    @staticmethod
    def _generate_random_roles(person_list_unique : list) -> dict:
        list_of_years = [str(85 + i) for i in range(15)] + ["0" + str(i) for i in range(10)] + [str(10 + i) for i in range(15)]
        
        return {person : f"Alum '{random.choice(list_of_years)}" for person in person_list_unique}

# Random City Generator
class RandomCityGenerator():
    def __init__(self, person_names_series : pd.Series) -> None:
        '''
        Inputs:
            person_names_series - pd.Series containing the list of randomly-generated person names.
        '''
        self.person_names_series = person_names_series
        self.person_list_complete = [row for idx, row in self.person_names_series.items()]
        self.person_list_unique = list(set(self.person_list_complete))

    def __call__(self) -> pd.Series:
        # In order to return the appropriate address, we need to make a copy of the information generated by this class' private method 
        # before returning it at the end of this dunder method.
        random_city_unique_dict, random_address_unique_dict = (copy.deepcopy(RandomCityGenerator._generate_random_address(self.person_list_unique)) for _ in range(2))
        
        # Here, we modify the data in random_city_unique_dict so that this dict only contains the city information. 
        random_city_unique_dict = {person : address[1] for person, address in zip(random_city_unique_dict.keys(), random_city_unique_dict.values())}
        
        random_cities_series = pd.Series([random_city_unique_dict[str(name)] for _, name in self.person_names_series.items()], index=range(len(self.person_list_complete)))
        
        # We make sure to return the random_address_unique_dict for use in the RandomAddressGenerator() class
        return random_cities_series, random_address_unique_dict

    @staticmethod
    def _generate_random_address(person_list_unique : list) -> dict:        
        return {person : gen_data.create_city_state_zip() for person in person_list_unique}

# Random Address Generator
class RandomAddressGenerator(RandomCityGenerator):
    def __init__(self, person_names_series : pd.Series, random_address_unique_dict : dict) -> None:
        super().__init__(person_names_series)

        self.random_address_unique_dict = random_address_unique_dict
        self.random_address_unique_dict = {person : f"{"".join([address[idx] + " " for idx in range(3)])}" for person, address in zip(self.random_address_unique_dict.keys(), self.random_address_unique_dict.values())}

    def __call__(self) -> pd.Series:
        random_address_unique_dict = self.random_address_unique_dict
        random_address_series = pd.Series([random_address_unique_dict[str(name)] for _, name in self.person_names_series.items()], index=range(len(self.person_list_complete)))
        return random_address_series


## Project DataFrame Generators
# Project 1
class RandomProject1Generator():
    def __init__(self, num_names_unique : int, num_names_complete : int, masters : bool = False, random_primary : bool = False, random_secondary : bool = False) -> None:
        '''
        Inputs:
            num_names_unique - The number of unique names you'd like to generate. Recommendation: ~75% of your total final pd.DataFrame should contain unique individuals.
            
            num_names_complete - The complete number of names you'd like to generate. This should correspond to the total number of entries contained in the pd.DataFrame you'd like to reproduce.
            
            masters - If True, this variable indicates that majors_list is a list of Master's degrees. Otherwise, majors_list is a list of 
            Bachelor's degrees. By default, this variable is False.

            random_primary - If True, a sequence of three digits (ranging from 0 to 9) will be added before the '@' symbol in the generated primary email 
            address. By default, this argument is set to False.

            random_secondary - The same as random_primary, except applied to the secondary email address.
        '''
        ## Load in list of US universities
        os.chdir("/Users/OscarBarnes/Python/Pinewood_Work/CSV Downloads")
        university_df = pd.read_csv("us_universities.csv")
        university_series = university_df["name"]
        university_list = [row for idx, row in university_series.items()]

        
        ## Load in list of college majors
        os.chdir("/Users/OscarBarnes/Python/Pinewood_Work/CSV Downloads/college_majors_list")
        
        # Bachelor's list
        bachelors_majors_series = pd.read_csv("majors-list.csv")["Major"]
        bachelors_majors_list = [row.lower().title() for idx, row in bachelors_majors_series.items()]
        
        # Master's list
        masters_majors_series = pd.read_csv("grad-students.csv")["Major"]
        masters_majors_list = [row.lower().title() for idx, row in masters_majors_series.items()]
        os.chdir("/Users/OscarBarnes/Python/Pinewood_Work")

        ## Initialize degrees lists
        # Bachelor's list
        bachelors_degree_list = ["AA", "AAS", "AS", "BA", "BBA", "BCE", "BComm", "BE", "BEd", "BFA", "BM", "BS", "BTM", "BVMS", "CE", "GED",
                                "Prof. Cert."]
        
        # Master's list
        masters_degree_list = ["DDS", "DNP", "DPM", "DPT", "DVM", "EdD", "GradDipSci", "JD", "LL.M", "M.Phil", "MA", "MBA", "MBT", "MCP",
                              "MD", "ME", "MEd", "MFA", "MM", "MPA", "MPH", "MPP", "MS", "MSA", "MSCM", "MSEd", "MSEE", "MSJ", "MSW", "MsX",
                              "OD", "PharmD", "PhD", "PsyD", "Residency", "ScD", "SLD", "SM"]


        ## Initialize & call modules
        self.name_series = RandomNameGenerator(num_names_unique, num_names_complete)()
        self.university_series = RandomUniversityGenerator(self.name_series)()
        self.field_of_study_series = RandomFieldOfStudyGenerator(self.name_series, masters_majors_list, True)() if masters else RandomFieldOfStudyGenerator(self.name_series, bachelors_majors_list, False)()
        self.degree_series = RandomDegreeGenerator(self.name_series, masters_degree_list, bachelors_degree_list, masters_majors_list, bachelors_majors_list, masters)()
        self.primary_email_address_series = RandomEmailAddressGenerator(self.name_series, random_primary)()
        self.secondary_email_address_series = RandomEmailAddressGenerator(self.name_series, random_secondary)()

        ## Initialize final dataframe
        self.complete_df = pd.concat([self.name_series, self.university_series, self.field_of_study_series, self.degree_series,
                                     self.primary_email_address_series, self.secondary_email_address_series], axis = 1)
        
        self.complete_df.rename(columns={self.complete_df.columns[0]: 'Name', self.complete_df.columns[1]: 'University',
                                        self.complete_df.columns[2]: 'Field of Study', self.complete_df.columns[3]: 'Degree',
                                        self.complete_df.columns[4]: 'Primary Email Address', self.complete_df.columns[5]: 'Secondary Email Address'}, inplace=True)

        
        ## Introduce some randomness to the final dataframe
        import random  # Have to do this for some reason
        
        dataset_size = num_names_complete 
        for _ in range(dataset_size // 2):            
            column_1_list = ["Field of Study", "Degree", "Primary Email Address", "Secondary Email Address"]
            column_1 = random.choice(column_1_list)
            
            column_2_list = column_1_list
            column_2_list.remove(column_1)
            column_2 = random.choice(column_2_list)
            
            self.complete_df.loc[random.choice([num for num in range(dataset_size)]), column_1] = '<None>' if ((column_1 == "Field of Study") or (column_1 == "Degree")) else np.nan
            self.complete_df.loc[random.choice([num for num in range(dataset_size)]), column_2] = '<None>' if ((column_2 == "Field of Study") or (column_2 == "Degree")) else np.nan

    def __call__(self, export : bool = False) -> pd.DataFrame:
        '''
        Input:
            export - If True, calling this class will export the DataFrame to a CSV file in your current working directory. By default,
            this argument is False.
        '''
        if export:
            self.complete_df.to_csv("Project_1_DataFrame.csv", index = False)
        else:
            return self.complete_df

# Project 2
class RandomProject2Generator():
    def __init__(self, num_names_unique : int, num_names_complete : int, masters : bool = False, random_primary : bool = False) -> None:
        '''
        Inputs:
            num_names_unique - The number of unique names you'd like to generate. Recommendation: ~75% of your total final pd.DataFrame should contain unique individuals.
            
            num_names_complete - The complete number of names you'd like to generate. This should correspond to the total number of entries contained in the pd.DataFrame you'd like to reproduce.
            
            masters - If True, this variable indicates that majors_list is a list of Master's degrees. Otherwise, majors_list is a list of 
            Bachelor's degrees. By default, this variable is False.

            random_primary - If True, a sequence of three digits (ranging from 0 to 9) will be added before the '@' symbol in the generated primary email 
            address. By default, this argument is set to False.
        '''
        ## Load in list of US universities
        os.chdir("/Users/OscarBarnes/Python/Pinewood_Work/CSV Downloads")
        university_df = pd.read_csv("us_universities.csv")
        university_series = university_df["name"]
        university_list = [row for idx, row in university_series.items()]

        
        ## Load in list of college majors
        os.chdir("/Users/OscarBarnes/Python/Pinewood_Work/CSV Downloads/college_majors_list")
        
        # Bachelor's list
        bachelors_majors_series = pd.read_csv("majors-list.csv")["Major"]
        bachelors_majors_list = [row.lower().title() for idx, row in bachelors_majors_series.items()]
        
        # Master's list
        masters_majors_series = pd.read_csv("grad-students.csv")["Major"]
        masters_majors_list = [row.lower().title() for idx, row in masters_majors_series.items()]
        os.chdir("/Users/OscarBarnes/Python/Pinewood_Work")

        ## Initialize degrees lists
        # Bachelor's list
        bachelors_degree_list = ["AA", "AAS", "AS", "BA", "BBA", "BCE", "BComm", "BE", "BEd", "BFA", "BM", "BS", "BTM", "BVMS", "CE", "GED",
                                "Prof. Cert."]
        
        # Master's list
        masters_degree_list = ["DDS", "DNP", "DPM", "DPT", "DVM", "EdD", "GradDipSci", "JD", "LL.M", "M.Phil", "MA", "MBA", "MBT", "MCP",
                              "MD", "ME", "MEd", "MFA", "MM", "MPA", "MPH", "MPP", "MS", "MSA", "MSCM", "MSEd", "MSEE", "MSJ", "MSW", "MsX",
                              "OD", "PharmD", "PhD", "PsyD", "Residency", "ScD", "SLD", "SM"]

        
        ## Initialize & call modules
        self.name_series = RandomNameGenerator(num_names_unique, num_names_complete)()
        self.person_id_series = RandomPersonIDGenerator(self.name_series)()
        self.person_roles_series = RandomRolesGenerator(self.name_series)()
        self.employer_series = RandomEmployerNameGenerator(self.name_series)()
        self.job_title_series = RandomJobTitleGenerator(self.name_series)()
        self.university_series = RandomUniversityGenerator(self.name_series)()
        self.degree_series = RandomDegreeGenerator(self.name_series, masters_degree_list, bachelors_degree_list, masters_majors_list, bachelors_majors_list, masters)()
        self.field_of_study_series = RandomFieldOfStudyGenerator(self.name_series, masters_majors_list, True)() if masters else RandomFieldOfStudyGenerator(self.name_series, bachelors_majors_list, False)()
        self.additional_notes_series = RandomAdditionalNotesGenerator(self.field_of_study_series, self.degree_series, masters)()
        self.home_phone_series = RandomPhoneNumberGenerator(self.name_series)()
        self.mobile_phone_series = RandomPhoneNumberGenerator(self.name_series)()
        self.primary_email_address_series = RandomEmailAddressGenerator(self.name_series, random_primary)()
        
        address_info = RandomCityGenerator(self.name_series)()
        self.city_series = address_info[0]
        self.primary_address_series = RandomAddressGenerator(self.name_series, address_info[1])()

        ## Initialize final DataFrame
        self.complete_df = pd.concat([self.name_series, self.person_id_series, self.person_roles_series, self.employer_series, 
                                     self.job_title_series, self.university_series, self.degree_series, self.field_of_study_series, 
                                     self.additional_notes_series, self.home_phone_series, self.mobile_phone_series, 
                                     self.primary_email_address_series, self.city_series, self.primary_address_series], axis=1)
        self.complete_df.rename(columns = {self.complete_df.columns[0]: "Full Name", self.complete_df.columns[1]: "Person ID",
                                          self.complete_df.columns[2]: "Roles", self.complete_df.columns[3]: "Employer", 
                                          self.complete_df.columns[4]: "Job Title", self.complete_df.columns[5]: "College",
                                          self.complete_df.columns[6]: "Degree", self.complete_df.columns[7]: "Major",
                                          self.complete_df.columns[8]: "Additional Notes", self.complete_df.columns[9]: "Home Phone",
                                          self.complete_df.columns[10]: "Mobile Phone", self.complete_df.columns[11]: "Primary Email Address",
                                          self.complete_df.columns[12]: "City", self.complete_df.columns[13]: "Primary Address"},
                                inplace = True)

        ## Introduce some missing values to the final DataFrame
        import random

        dataset_size = num_names_complete
        for _ in range(dataset_size // 2):
            # List of columns to choose from
            column_list = ["Degree", "Major", "Additional Notes", "Home Phone", "Mobile Phone", "Primary Email Address", "City", "Primary Address"]

            # First column which will have a particular entry replaced with a missing value
            column_1 = random.choice(column_list)

            # Second column which will have a particular entry replaced with a missing value
            column_list.remove(column_1)
            column_2 = random.choice(column_list)

            # Third column which will have a particular entry replaced with a missing value
            column_list.remove(column_2)
            column_3 = random.choice(column_list)

            # Fourth column which will have a particular entry replaced with a missing value
            column_list.remove(column_3)
            column_4 = random.choice(column_list)

            # Randomly replacing entries in self.complete_df with missing values 
            self.complete_df.loc[random.choice([num for num in range(dataset_size)]), column_1] = random.choice(['<None>', np.nan])
            self.complete_df.loc[random.choice([num for num in range(dataset_size)]), column_2] = random.choice(['<None>', np.nan])
            self.complete_df.loc[random.choice([num for num in range(dataset_size)]), column_3] = random.choice(['<None>', np.nan])
            self.complete_df.loc[random.choice([num for num in range(dataset_size)]), column_4] = random.choice(['<None>', np.nan])
                

    def __call__(self, export : bool = False) -> pd.DataFrame:
        '''
        Input:
            export - If True, calling this class will export the DataFrame to a CSV file in your current working directory. By default,
            this argument is False.
        '''
        if export:
            self.complete_df.to_csv("Project_2_DataFrame.csv", index = False)
        else:
            return self.complete_df

# Project 3
class RandomProject3Generator():
    def __init__(self, num_names_unique : int, num_names_complete : int, masters : bool = False, random_primary : bool = False, random_secondary : bool = False) -> None:
        '''
        Inputs:
            num_names_unique - The number of unique names you'd like to generate. Recommendation: ~75% of your total final pd.DataFrame should contain unique individuals.
            
            num_names_complete - The complete number of names you'd like to generate. This should correspond to the total number of entries contained in the pd.DataFrame you'd like to reproduce.
            
            masters - If True, this variable indicates that majors_list is a list of Master's degrees. Otherwise, majors_list is a list of 
            Bachelor's degrees. By default, this variable is False.

            random_primary - If True, a sequence of three digits (ranging from 0 to 9) will be added before the '@' symbol in the generated primary email 
            address. By default, this argument is set to False.

            random_secondary - The same as random_primary, except applied to the secondary email address.
        '''
        ## Load in list of US universities
        os.chdir("/Users/OscarBarnes/Python/Pinewood_Work/CSV Downloads")
        university_df = pd.read_csv("us_universities.csv")
        university_series = university_df["name"]
        university_list = [row for idx, row in university_series.items()]

        
        ## Load in list of college majors
        os.chdir("/Users/OscarBarnes/Python/Pinewood_Work/CSV Downloads/college_majors_list")
        
        # Bachelor's list
        bachelors_majors_series = pd.read_csv("majors-list.csv")["Major"]
        bachelors_majors_list = [row.lower().title() for idx, row in bachelors_majors_series.items()]
        
        # Master's list
        masters_majors_series = pd.read_csv("grad-students.csv")["Major"]
        masters_majors_list = [row.lower().title() for idx, row in masters_majors_series.items()] + ["Residency", "Fellowship"]
        os.chdir("/Users/OscarBarnes/Python/Pinewood_Work")

        ## Initialize degrees lists
        # Bachelor's list
        bachelors_degree_list = ["AA", "AAS", "AS", "BA", "BBA", "BCE", "BComm", "BE", "BEd", "BFA", "BM", "BS", "BTM", "BVMS", "CE", "GED",
                                "Prof. Cert."]
        
        # Master's list
        masters_degree_list = ["DDS", "DNP", "DPM", "DPT", "DVM", "EdD", "GradDipSci", "JD", "LL.M", "M.Phil", "MA", "MBA", "MBT", "MCP",
                              "MD", "ME", "MEd", "MFA", "MM", "MPA", "MPH", "MPP", "MS", "MSA", "MSCM", "MSEd", "MSEE", "MSJ", "MSW", "MsX",
                              "OD", "PharmD", "PhD", "PsyD", "ScD", "SLD", "SM"]

        
        ## Initialize & call modules
        self.name_series = RandomNameGenerator(num_names_unique, num_names_complete)()
        self.employer_series = RandomEmployerNameGenerator(self.name_series)()
        self.job_title_series = RandomJobTitleGenerator(self.name_series)()
        self.university_series = RandomUniversityGenerator(self.name_series)()
        self.field_of_study_series = RandomFieldOfStudyGenerator(self.name_series, masters_majors_list, True)() if masters else RandomFieldOfStudyGenerator(self.name_series, bachelors_majors_list, False)()
        self.degree_series = RandomDegreeGenerator(self.name_series, masters_degree_list, bachelors_degree_list, masters_majors_list, bachelors_majors_list, masters)()
        self.additional_notes_series = RandomAdditionalNotesGenerator(self.field_of_study_series, self.degree_series, masters)()
        self.primary_email_address_series = RandomEmailAddressGenerator(self.name_series, random_primary)()
        self.secondary_email_address_series = RandomEmailAddressGenerator(self.name_series, random_secondary)()

        ## Initialize final DataFrame
        self.complete_df = pd.concat([self.name_series, self.employer_series, self.job_title_series, self.university_series, 
                                      self.field_of_study_series, self.degree_series, self.additional_notes_series, 
                                      self.primary_email_address_series, self.secondary_email_address_series], axis=1)
        self.complete_df.rename(columns = {self.complete_df.columns[0]: "Name", self.complete_df.columns[1]: "Employer",
                                          self.complete_df.columns[2]: "Job Title", self.complete_df.columns[3]: "University", 
                                          self.complete_df.columns[4]: "Field of Study", self.complete_df.columns[5]: "Degree",
                                          self.complete_df.columns[6]: "Additional Notes", self.complete_df.columns[7]: "Primary Email Address",
                                          self.complete_df.columns[8]: "Secondary Email Address"},
                                inplace = True)

        ## Introduce some missing values to the final DataFrame
        import random

        dataset_size = num_names_complete
        for _ in range(dataset_size // 2):
            column_list = [str(self.complete_df.columns[idx]) for idx in range(len(list(self.complete_df.columns)))]

            # First column which will have a particular entry replaced with a missing value OR randomly modify the value in another column
            column_1 = random.choice(column_list)

            # Second column which will have a particular entry replaced with a missing value OR randomly modify the value in another column
            column_list.remove(column_1)
            column_2 = random.choice(column_list)

            # Third column which will have a particular entry replaced with a missing value OR randomly modify the value in another column
            column_list.remove(column_2)
            column_3 = random.choice(column_list)

            # Miscellaneous counters we'll use below
            university_counter = 0
            degree_counter = 0

            # Looping through each column
            for column in [column_1, column_2, column_3]:
                entry_choice = random.choice([num for num in range(dataset_size)])
                
                if column == "Employer":
                    self.complete_df.loc[entry_choice, "Job Title"] = "(College)"
                    self.complete_df.loc[entry_choice, column] = "Still in college."
                elif column == "Field of Study":                    
                    if not masters:
                        # Choose to either mess with the formatting of the Bachelor's degree in the Additional Notes column, or to fill the University, Field of Study, and Degree columns with empty values
                        bachelors_not_empty = random.choice([True, False])

                        if bachelors_not_empty:
                            # Replace the "Official Major Title: " text with either itself or another variation accounted for by the fill_na_values function
                            text_choice = random.choice(["Official Major Title: ", "Official Name of Major: ", "Official Major: "])
                            self.complete_df.loc[entry_choice, "Additional Notes"] = str(self.complete_df.loc[entry_choice, "Additional Notes"]).replace("Official Major Title: ", text_choice)
    
                            # Randomly choose to keep or remove quotation marks
                            keep_quotation_marks = random.choice([True, False])
                            if not keep_quotation_marks:
                                self.complete_df.loc[entry_choice, "Additional Notes"] = str(self.complete_df.loc[entry_choice, "Additional Notes"]).replace('"', '')
                        else:
                            self.complete_df.loc[entry_choice, column] = random.choice(["<None>", np.nan])
                            self.complete_df.loc[entry_choice, "University"] = random.choice(["<None>", np.nan])
                            self.complete_df.loc[entry_choice, "Degree"] = random.choice(["<None>", np.nan])

                            university_counter += 1
                            degree_counter += 1
                    else:
                        # Choose to either mess with the formatting of the Master's degree in the Additional Notes column, or to fill the University, Field of Study, and Degree columns with empty values 
                        masters_not_empty = random.choice([True, False])

                        if masters_not_empty:
                            # Choose whether or not to add quotation marks
                            add_quotation_marks = random.choice([True, False])
                            if add_quotation_marks:
                                end_character = [value for value in range(len(str(self.complete_df.loc[entry_choice, "Additional Notes"]).split(";")[0]))][-1]
                                self.complete_df.loc[entry_choice, "Additional Notes"] = '"' + str(self.complete_df.loc[entry_choice, "Additional Notes"])[:end_character+1] + '"' + str(self.complete_df.loc[entry_choice, "Additional Notes"])[1+end_character:]
                        else:
                            self.complete_df.loc[entry_choice, column] = random.choice(["<None>", np.nan])
                            self.complete_df.loc[entry_choice, "University"] = random.choice(["<None>", np.nan])
                            self.complete_df.loc[entry_choice, "Degree"] = random.choice(["<None>", np.nan])

                            university_counter += 1
                            degree_counter += 1
                else:
                    if column == "University":
                        if university_counter == 0:
                            self.complete_df.loc[entry_choice, column] = random.choice(["<None>", np.nan])
                    elif column == "Degree":
                        if degree_counter == 0:
                            self.complete_df.loc[entry_choice, column] = random.choice(["<None>", np.nan])
                    else:
                        if column != "Job Title":
                            self.complete_df.loc[entry_choice, column] = random.choice(["<None>", np.nan])

    def __call__(self, export : bool = False) -> pd.DataFrame:
        '''
        Input:
            export - If True, calling this class will export the DataFrame to a CSV file in your current working directory. By default,
            this argument is False.
        '''
        if export:
            self.complete_df.to_csv("Project_3_DataFrame.csv", index = False)
        else:
            return self.complete_df

# Project 4
class RandomProject4Generator():
    def __init__(self, num_names_unique : int, num_names_complete : int, masters : bool = False, random_primary : bool = False, random_secondary : bool = False) -> None:
        '''
        Inputs:
            num_names_unique - The number of unique names you'd like to generate. Recommendation: ~75% of your total final pd.DataFrame should contain unique individuals.
            
            num_names_complete - The complete number of names you'd like to generate. This should correspond to the total number of entries contained in the pd.DataFrame you'd like to reproduce.
            
            masters - If True, this variable indicates that majors_list is a list of Master's degrees. Otherwise, majors_list is a list of 
            Bachelor's degrees. By default, this variable is False.

            random_primary - If True, a sequence of three digits (ranging from 0 to 9) will be added before the '@' symbol in the generated primary email 
            address. By default, this argument is set to False.

            random_secondary - The same as random_primary, except applied to the secondary email address.
        '''
        ## Load in list of US universities
        os.chdir("/Users/OscarBarnes/Python/Pinewood_Work/CSV Downloads")
        university_df = pd.read_csv("us_universities.csv")
        university_series = university_df["name"]
        university_list = [row for idx, row in university_series.items()]

        
        ## Load in list of college majors
        os.chdir("/Users/OscarBarnes/Python/Pinewood_Work/CSV Downloads/college_majors_list")
        
        # Bachelor's list
        bachelors_majors_series = pd.read_csv("majors-list.csv")["Major"]
        bachelors_majors_list = [row.lower().title() for idx, row in bachelors_majors_series.items()]
        
        # Master's list
        masters_majors_series = pd.read_csv("grad-students.csv")["Major"]
        masters_majors_list = [row.lower().title() for idx, row in masters_majors_series.items()] + ["Residency", "Fellowship"]
        os.chdir("/Users/OscarBarnes/Python/Pinewood_Work")

        ## Initialize degrees lists
        # Bachelor's list
        bachelors_degree_list = ["AA", "AAS", "AS", "BA", "BBA", "BCE", "BComm", "BE", "BEd", "BFA", "BM", "BS", "BTM", "BVMS", "CE", "GED",
                                "Prof. Cert."]
        
        # Master's list
        masters_degree_list = ["DDS", "DNP", "DPM", "DPT", "DVM", "EdD", "GradDipSci", "JD", "LL.M", "M.Phil", "MA", "MBA", "MBT", "MCP",
                              "MD", "ME", "MEd", "MFA", "MM", "MPA", "MPH", "MPP", "MS", "MSA", "MSCM", "MSEd", "MSEE", "MSJ", "MSW", "MsX",
                              "OD", "PharmD", "PhD", "PsyD", "ScD", "SLD", "SM"]

        
        ## Initialize & call modules
        self.name_series = RandomNameGenerator(num_names_unique, num_names_complete)()
        self.employer_series = RandomEmployerNameGenerator(self.name_series)()
        self.job_title_series = RandomJobTitleGenerator(self.name_series)()
        self.university_series = RandomUniversityGenerator(self.name_series)()
        self.field_of_study_series = RandomFieldOfStudyGenerator(self.name_series, masters_majors_list, True)() if masters else RandomFieldOfStudyGenerator(self.name_series, bachelors_majors_list, False)()
        self.degree_series = RandomDegreeGenerator(self.name_series, masters_degree_list, bachelors_degree_list, masters_majors_list, bachelors_majors_list, masters)()
        self.additional_notes_series = RandomAdditionalNotesGenerator(self.field_of_study_series, self.degree_series, masters)()
        self.primary_email_address_series = RandomEmailAddressGenerator(self.name_series, random_primary)()
        self.secondary_email_address_series = RandomEmailAddressGenerator(self.name_series, random_secondary)()

        ## Initialize final DataFrame
        self.complete_df = pd.concat([self.name_series, self.employer_series, self.job_title_series, self.university_series, 
                                      self.field_of_study_series, self.degree_series, self.additional_notes_series, 
                                      self.primary_email_address_series, self.secondary_email_address_series], axis=1)
        self.complete_df.rename(columns = {self.complete_df.columns[0]: "Name", self.complete_df.columns[1]: "Employer",
                                          self.complete_df.columns[2]: "Job Title", self.complete_df.columns[3]: "University", 
                                          self.complete_df.columns[4]: "Field of Study", self.complete_df.columns[5]: "Degree",
                                          self.complete_df.columns[6]: "Additional Notes", self.complete_df.columns[7]: "Primary Email Address",
                                          self.complete_df.columns[8]: "Secondary Email Address"},
                                inplace = True)

        ## Introduce some missing values to the final DataFrame
        import random

        dataset_size = num_names_complete
        for _ in range(dataset_size // 2):
            column_list = [str(self.complete_df.columns[idx]) for idx in range(len(list(self.complete_df.columns)))]

            # First column which will have a particular entry replaced with a missing value OR randomly modify the value in another column
            column_1 = random.choice(column_list)

            # Second column which will have a particular entry replaced with a missing value OR randomly modify the value in another column
            column_list.remove(column_1)
            column_2 = random.choice(column_list)

            # Third column which will have a particular entry replaced with a missing value OR randomly modify the value in another column
            column_list.remove(column_2)
            column_3 = random.choice(column_list)

            # Miscellaneous counters we'll use below
            university_counter = 0
            degree_counter = 0

            # Looping through each column
            for column in [column_1, column_2, column_3]:
                entry_choice = random.choice([num for num in range(dataset_size)])
                
                if column == "Employer":
                    self.complete_df.loc[entry_choice, "Job Title"] = "(College)"
                    self.complete_df.loc[entry_choice, column] = "Still in college."
                elif column == "Field of Study":                    
                    if not masters:
                        # Choose to either mess with the formatting of the Bachelor's degree in the Additional Notes column, or to fill the University, Field of Study, and Degree columns with empty values
                        bachelors_not_empty = random.choice([True, False])

                        if bachelors_not_empty:
                            # Replace the "Official Major Title: " text with either itself or another variation accounted for by the fill_na_values function
                            text_choice = random.choice(["Official Major Title: ", "Official Name of Major: ", "Official Major: "])
                            self.complete_df.loc[entry_choice, "Additional Notes"] = str(self.complete_df.loc[entry_choice, "Additional Notes"]).replace("Official Major Title: ", text_choice)
    
                            # Randomly choose to keep or remove quotation marks
                            keep_quotation_marks = random.choice([True, False])
                            if not keep_quotation_marks:
                                self.complete_df.loc[entry_choice, "Additional Notes"] = str(self.complete_df.loc[entry_choice, "Additional Notes"]).replace('"', '')
                        else:
                            self.complete_df.loc[entry_choice, column] = random.choice(["<None>", np.nan])
                            self.complete_df.loc[entry_choice, "University"] = random.choice(["<None>", np.nan])
                            self.complete_df.loc[entry_choice, "Degree"] = random.choice(["<None>", np.nan])

                            university_counter += 1
                            degree_counter += 1
                    else:
                        # Choose to either mess with the formatting of the Master's degree in the Additional Notes column, or to fill the University, Field of Study, and Degree columns with empty values 
                        masters_not_empty = random.choice([True, False])

                        if masters_not_empty:
                            # Choose whether or not to add quotation marks
                            add_quotation_marks = random.choice([True, False])
                            if add_quotation_marks:
                                end_character = [value for value in range(len(str(self.complete_df.loc[entry_choice, "Additional Notes"]).split(";")[0]))][-1]
                                self.complete_df.loc[entry_choice, "Additional Notes"] = '"' + str(self.complete_df.loc[entry_choice, "Additional Notes"])[:end_character+1] + '"' + str(self.complete_df.loc[entry_choice, "Additional Notes"])[1+end_character:]
                        else:
                            self.complete_df.loc[entry_choice, column] = random.choice(["<None>", np.nan])
                            self.complete_df.loc[entry_choice, "University"] = random.choice(["<None>", np.nan])
                            self.complete_df.loc[entry_choice, "Degree"] = random.choice(["<None>", np.nan])

                            university_counter += 1
                            degree_counter += 1
                else:
                    if column == "University":
                        if university_counter == 0:
                            self.complete_df.loc[entry_choice, column] = random.choice(["<None>", np.nan])
                    elif column == "Degree":
                        if degree_counter == 0:
                            self.complete_df.loc[entry_choice, column] = random.choice(["<None>", np.nan])
                    else:
                        if column != "Job Title":
                            self.complete_df.loc[entry_choice, column] = random.choice(["<None>", np.nan])

    def __call__(self, export : bool = False) -> pd.DataFrame:
        '''
        Input:
            export - If True, calling this class will export the DataFrame to a CSV file in your current working directory. By default,
            this argument is False.
        '''
        if export:
            self.complete_df.to_csv("Project_3_DataFrame.csv", index = False)
        else:
            return self.complete_df